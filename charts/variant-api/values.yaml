# Default values for istio.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

nameOverride: ""
fullnameOverride: "schedule-adherence"

istio:
  enabled: true
  ## For traffic to the cluster
  ingress:
    # # Should the service be exposed via public ingress gateway?
    public: true
    # # Provide only the full hostname
    host: ops-drivevariant.com

    # Make this as true if you want to handle the rewrite inside the app
    disableRewrite: false

    # Add endpoints to be rerouted to / in public access
    redirects:
      - prefix: /hidden
    # # Should the endpoint be external or internal
    backend:
      service:
        ## These values can be template variables
        # name: {{ .Values.ReleaseName }}
        # port: {{ .Global.service.port }}
        name: test
        ## port should be number
        port: 1234

  ## For external traffic
  egress:
    # ## List of hostnames and ports
    # # Hosts should be FQDN
    # - name:
    #   hosts:
    #     - "test.example.com"
    #   addresses:
    #     - "10.0.0.1"
    #   ports:
    #     - number: 123
    #       ## MUST BE one of HTTP|HTTPS|GRPC|HTTP2|MONGO|TCP|TLS
    #       protocol: HTTPS

serviceMonitor:
  enabled: true
  interval: 10s
  scrapeTimeout: 10s

service:
  # Port # exposed by the Kubernetes Service which will point to your deployed Pods
  port: 80
  # Port # that exposes your HTTP application in your image
  targetPort: 9000
  type: ClusterIP

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 5
  targetCPUUtilizationPercentage: 80

image:
  # SET via terrform syntax {alias}.image.tag
  tag: abc123
  pullPolicy: Always

resources:
  limits:
    cpu: 1
    memory: 768Mi
  requests:
    cpu: .1
    memory: 384Mi

# SET via terrform syntax {alias}.revision
revision: abc123

serviceAccount:
  # SET via terrform syntax {alias}.serviceAccount.name
  name: service-account
  # SET via terrform syntax {alias}.serviceAccount.roleArn if AWS permissions are required
  roleArn: amazon-role

# SET via terraform syntax {alias}.args[0], {alias}.args[1], etc. for the number of args required
args: [some, args]

# SET via terraform syntax in pairs of {alias}.envVars[0].name, {alias}.envVars[0].value
envVars:
  - name: env1
    value: env1
  - name: env2
    value: env2
